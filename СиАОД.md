# Ответы на вопросы по струкутурам и алгоритмам обработки данных

**1. В чем заключаются достоинства и недостатки последовательного и связанного способов реализации динамических структур данных?**

В первом случае базовой структурой, на основе которой строится новая структура данных, является массив. Выделается определенная часть памяти, достаточная для хранения максимального количества элементов. Такой подход является более простым в реализации, но у него есть минусы:

    1. Изменение длины структуры не должно выходить за отведенное ей
       количество памяти;
    2. Неэкономное использование памяти;

Реализация связанным способом более сложна, но она лишена недостатков последовательного способа.

**2. Назовите принципы функционирования стека, очереди и деки?**

> *Стеком* называется упорядоченный набор элементов, в котором включение новых элементов и исключение существующих выполняются только с одного конца, называемого вершиной стека. Каждый элемент стека характеризуется одним и тем же набором полей. Логическая структура стека:

![Stack](https://i.imgur.com/IkwrAig.png)

#### Рис.1. Логическая структура стека

> *Очередью* называется упорядоченный набор элементов, которые могут исключаться с одного ее конца (называемого началом очереди), а включаться с другого конца (называемого концом очереди). Каждый элемент очереди характеризуется одним и тем же набором полей. Логическая структура очереди:

![Queue](https://i.imgur.com/rTl9Y9v.png)

#### Рис.2. Логическая структура очереди

> *Деком* (DEQ – от английского double ended queue, очередь с двумя концами) называется упорядоченный набор элементов, включение и исключение элементов в котором могут осуществляться с любого из двух его концов. Логическая структура дека:

![Dequeue](https://i.imgur.com/Fi2jwku.png)

#### Рис.3. Логическая структура дека

**3. Реализуйте класс – стек с базовым набором методов на основе массива нетипированных указателей на размещенные в динамической памяти элементы.**

```c++
template <typename T>
class Stack
{
private:
    T *stackPointer;                // Указатель на стек
    const int size;                 // Максимальное количество
                                    // элементов в стеке
    int top;                        // Номер текущего элемента
public:
    Stack(int = 10);                // Конструктор
    ~Stack();                       // Деструктор

    inline void push(const T & );   // Поместить элемент
                                    // в вершину стека
    inline T pop();                 // Удалить элемент из вершины
                                    // стека и вернуть его
    inline bool empty() const;      // Пуст ли стек
};

// Реализация методов шаблона класса Stack

// Конструктор Стека
template <typename T>
Stack<T>::Stack(int maxSize) :
    size(maxSize) // Инициализация константы
{
    stackPointer = new T[size]; // Выделить память под стек
    top = 0; // Инициализируем текущий элемент нулем;
}

// Функция деструктора Стека
template <typename T>
Stack<T>::~Stack()
{
    delete [] stackPointer; // Удаляем стек
}

// Функция добавления элемента в стек
template <typename T>
inline void Stack<T>::push(const T &value)
{
    // Проверяем размер стека
    assert(top < size);
    stackPointer[top++] = value; // Помещаем элемент в стек
}

// Функция удаления элемента из стека
template <typename T>
inline T Stack<T>::pop()
{
    // Проверяем размер стека
    assert(top > 0);
    return stackPointer[--top]; // Удаляем элемент из стека
}

// Пуст ли стек
template <typename T>
inline bool Stack<T>::empty() const
{
    return (size == 0 ? true : false);
}
```

**4. С использованием основных методов работы со стеком составьте программу копирования элементов стека в новый стек в том же порядке.**

```c++
tempate <typename T>
Stack<T> copy_stack(Stack<T> from)
{
    /*
    * Нужна дополнительная временная переменная
    * для копирования в том же порядке,
    * т.к. можно использовать только основные методы стека:
    * push, pop и empty
    */

    Stack<T> dest;
    Stack<T> tmp;

    while (from.empty() != true) {  // Копирование во временный стек
        tmp.push(from.pop());
    }
    while (tmp.empty() != true) { // Копирование в стек назначения
        dest.push(tmp.pop());
    }

    return dest;
}
```

**5. Реализуйте метод копирования элементов очереди в новую очередь.**

```c++
/*
* Программа написанна с учетом того,
* что можно использовать только основные методы очереди:
* insert, remove и empty
*/

template <typename T>
Queue<T> copy_queue(Queue<T> from)
{
    Queue<T> dest;

    while(from.emty() != true) {
        dest.insert(from.remove());
    }

    return dest;
}
```

**6. Перевод из инфиксной формы записи выражения в префиксную.**

Инфиксное выражение сканируется справа налево, и префиксная строка строится также справа налево. Алгоритм преобразования такой же, как и при преобразовании в постфиксную форму (см. вопрос №7), только открывающие скобки меняются на закрывающие и, наоборот, при определении приоритета операции «<=» изменяется на «<», чтобы равноприоритетные операции выполнялись слева направо.

**7. Перевод инфиксной формы записи выражения в постфиксную.**

Инфиксное выражение сканируется слева направо, и в зависимости от вида очередного элемента выражения выполняется одно из следующих действий:

|  Элемент выражения  |  Действие  |
| :--- | :--- |
|  Открывающая скобка  |  Вталкивание элемента в стек.  |
|  Операнд  |  Запись элемента в постфиксную строку.  |
|  Закрывающая скобка  |  Выталкивание элементов из стека до первой открывающей скобки и запись их в постфиксную строку, затем выталкивание самой открывающей скобки без записи ее в постфиксную строку. Если перед выполнением этой операции стек оказался пустым, значит, для дан-ной закрывающей скобки не было парной открываю-щей, т.е. возникла исключительная ситуация.  |
|  Операция  |  Если стек не пуст, и приоритет операции ниже (<=), чем у верхней операции в стеке, то выталкивание элемен-тов из стека до операции с меньшим приоритетом или до опустошения стека и запись их в постфиксную строку; в противном случае стек не изменяется. Затем вталкивание операции в стек.  |

#### Табл.1. Перевод инфиксной формы записи выражения в постфиксную

После просмотра выражения выталкиваются из стека и записываются в постфиксную строку все оставшиеся в стеке операции.

**8. С использованием стандартного набора методов составьте программу переноса из очереди строк в новую очередь элементов начинающихся на буквы «F» или «f».**

```c++
Queue<string> transfer_fbegins_lines(Queue<string> from)
{
    Queue<string> dest;
    string tmp;

    while (from.empty() != true) {
        tmp = from.remove();
        if (tmp[0].tolower() == 'f') {
            dest.push(tmp);
        }
    }
}
```

**9. С использованием стандартного набора методов составьте программу записи элементов очереди в новую очередь в обратном порядке.**

```c++
// Рекурсивная функция
template <typename T>
void copy_reverse_queue(Queue<T> &dest, Queue<T> from)
{
    T tmp;

    // Условие выхода из рекурсии
    if (from.empty() == true) {
        return;
    }

    tmp = from.remove();
    copy_reverse_queue(dest, from);
    dest.insert(tmp);
}
```

**10. АТД – очередь. Ее свойства. Способы реализации.**

См. вопрос №2.
Очередь может быть реализована с помощью массива; односвязаного списка; с помощью двусвязаного списка; на двух стеках.
Реализация на двух стеках:

```c++
template <typename T>
class Queue {
private:
    Stack<T> st1;
    Stack<T> st2;
public:
    Queue();                        // Конструктор
    ~Queue();                       // Деструктор
    inline void insert(T value);    // Вставить элемент в очередь
    inline void remove();           // Удалить первый элемент очереди
    inline bool empty() const;      // Пуста ли очередь
}

template <typename T>
Queue<T>::Queue()
{
}

template <typename T>
Queue<T>::~Queue()
{
}

template <typename T>
void Queue<T>::insert(T value)
{
    st1.push(value);
}

template <typename T>
void Queue<T>::remove()
{
    if (st2.empty() == true) {
        if (st1.empty() == true) {
            exit(-1);
        }

        while(st1.empty != true) {
            st2.insert(st1.remove());
        }
    }

    return st2.remove();
}
```

**11. Разработать класс «Бинарное дерево поиска». Реализовать метод вставки нового узла в дерево.**

```c++
template <typename T>
class SearchTree : public BinaryTree<T> {
public:
    SearchTree();                       // Конструктор
    ~SearchTree();                      // Деструктор
    Node& search(T value);              // Поиск элемента
    Node& search_with_adding(T value);  // Поиск элемента с включением
    Node& insert(T value);              // Вставить новый узел
    void delete(T value);               // Удаление элемента
}

template <typename T>
Node& SearchTree<T>::insert(T value)
{
    Node *nd = root;

    while (nd != null) {
        if (value < nd.value) {
            nd = nd->left_son;
        }
        else {
            nd = nd->right_son;
        }
    }

    nd->value = value;
    nd->left_son = null;
    nd->right_son = null;

    return *nd;
}
```

**12. АТД – Дек. Его свойства. Способы реализации.**

См. вопрос №2.
Реализовать можно на массиве, на связаных списках.

**13. Класс «Бинарное дерево поиска». Реализуйте метод поиска элемента в дереве.**

Бинарные деревья часто используются для представления множества данных, среди которых идет поиск элементов по уникальному ключу. Если дерево организовано так, что для каждого узла t все ключи его левого поддерева меньше ключа t, а все ключи правого поддерева t больше ключа t, то такое дерево будем называть деревом поиска. В нем легко найти элемент с нужным ключом – достаточно, начав с корня, двигаться в левое или правое поддерево на основании сравнения заданного ключа с ключом текущего узла. Известно, что из n элементов можно построить бинарное дерево с высотой не более log_2(n), поэтому, если дерево идеально сбалансировано, поиск среди его n элементов выполняется максимум за log_2(n) сравнений. Подобные деревья широко используются и для сортировки больших массивов данных, так как обход дерева поиска слева направо дает отсортированную в порядке возрастания последова-тельность ключей.

```c++
template <typename T>
Node& SearchTree<T>::search(T value)
{
    Node *nd = root;

    while (nd->value != value && nd != null) {
        if (value < nd.value) {
            nd = nd->left_son;
        }
        else {
            nd = nd->right_son;
        }
    }

    return *nd;
}
```

**14. АТД – Очередь с приоритетом. Ее свойства. Способы реализации.**

Приоритетная очередь — это абстрактная структура данных наподобие стека или очереди, где у каждого элемента есть приоритет. Элемент с более высоким приоритетом находится перед элементом с более низким приоритетом. Если у  элементов одинаковые приоритеты, они располагаются в зависимости от своей позиции в очереди. Обычно  приоритетные очереди реализуются с помощью стеков. Обязательные операции:

    1. Добавить элемент;
    2. Извлечь максимум (минимум).

Реализация может быть *наивной* и *обычной*.

*Наивная*:

> В качестве наивной реализации мы можем взять обычный список и при добавлении нового элемента класть его в конец, а при запросе элемента с максимальным приоритетом проходить по всему списку. Тогда операция insert будет выполняться за O(1), а extractMin или extractMax за O(n).

*Обычная*:

> Для лучшей производительности приоритетные очереди реализуют с помощью куч, что позволяет выполнять операции вставки и удаления за O(log(n)). Использование специальных куч, таких как Фибоначчиева куча и спаренная куча, позволяет еще больше улучшить асимптотику некоторый операций.

**15. Класс Идеально Сбалансированное Бинарное Дерево. Реализуйте алгоритм прямого обхода дерева в глубину.**

Бинарное дерево называется идеально сбалансированным, если для каждой его вершины количество вершин в левом и правом поддереве различаются не более чем на 1.

![Примеры идеально сбалансированных бинарных деревьев](http://khpi-iip.mipk.kharkiv.edu/library/datastr/book_sod/kgsu/ris68_1.jpg)

#### Рис.4. Примеры идеально сбалансированных бинарных деревьев

![Рисунок глубоких обходов](https://hsto.org/files/654/015/a63/654015a637ab473cbbe11a1adcc993c5.png)

#### Рис.5. Виды глубоких обходов

Реализация прямого обхода дерева в глубину:

```c++
void direct_print(TreeNode *root)
{
    if (root == NULL)           // Базовый случай
    {
       return;
    }
    cout << root->data << " ";
    direct_print(root->left);   //рекурсивный вызов левого поддерева
    direct_print(root->right);  //рекурсивный вызов правого поддерева
}
```

**16. АТД Стек. Свойства. Способы реализации**

См. вопрос №2. Реализация возможна на массиве, связаном списке.

**17. Класс Хеш-таблица. Разрешение коллизий – цепное хеширование. Реализуйте метод вставки в таблицу нового узла с проверкой коэффициента нагрузки таблицы и рехеширования.**

> Хэш-табли́ца или хеш-табли́ца — это структура данных, реализующая интерфейс ассоциативного массива, а именно, она позволяет хранить пары (ключ, значение) и выполнять три операции: операцию добавления новой пары, операцию поиска и операцию удаления пары по ключу.

Выполнение операции в хеш-таблице начинается с вычисления хеш-функции от ключа. Получающееся хеш-значение i = hash(key) играет роль индекса в массиве H. Затем выполняемая операция (добавление, удаление или поиск) перенаправляется объекту, который хранится в соответствующей ячейке массива H[i].

> Ситуация, когда для различных ключей получается одно и то же хеш-значение, называется *коллизией*.

Способы разрешения коллизий:

    1. Метод цепочек;
    2. Прямая адресация.

Реализация метода вставки в таблицу нового узла с проверкой коэффициента нагрузки таблицы и рехеширования:

```c++
#define MAX 256
#define LIMIT 0.8

template <typename T>
struct Cell {
    bool occupied;
    T value;
    Cell *next;     // Список коллизий
};

template <typaneme T>
class Hash_table {
private:
    Cell<T> table[MAX];
    int counter;
    static double limit = LIMIT;

    int hash(T value);
    void rehash();
public:
    // ...
    void add(T val);
    // ...
}

template <typename T>
void Hash_table<T>::add(T val)
{
    int i;
    double load_factor;
    Cell *old, *tmp;

    i = hash(val);
    if (table[i].occupied == false || table[i].value == val) {
        table[i].value = val;
    }
    else {
        tmp = table[i].next;
        while (tmp != NULL)) {
            old = tmp;
            tmp = tmp->next;
        }

        old->next = new Cell;
        old->next->value = val;
        old->next->next = NULL;
    }

    /* Подсчет коэффициента загрузки и вызов рехеширования при перегрузке */
    load_factor = counter / MAX;
    if (load_factor >= limit) {
        rehash();
    }
}
```

**18. АТД – Линейный список. Свойства. Способы реализации**

> *Линейный список* представляет собой упорядоченный набор эле-ментов, в котором включение новых элементов и исключение суще-ствующих могут выполняться в любом месте списка. Каждый элемент списка характеризуется одним и тем же набором полей. Логическая структура линейного списка:

![List](https://i.imgur.com/oQx4zcT.png)

#### Рис.6. Логическая структура линейного списка

Над линейным списком l могут быть выполнены все операции, определенные для стека, очереди и дека, а также следующие операции:А

    1) Включение элемента со значением v в список после элемента
       с заданным адресом p – InsertAfter(l,p,v);
    2) Включение элемента со значением v в список l перед элементом
       с заданным адресом p – InsertBefore(l,p,v);
    3) Исключение из списка l элемента с адресом p – Delete(l,p);
    4) Исключение из списка l элемента, следующего за элементом
       с адресом p – DeleteAfter(l,p);
    5) Поиск в списке l элемента с заданным значением v – Search(l,v)
       и возвращение его адреса.

Возможны реализации в виде односвязаного списка, двусвязаного списка и кольцевого связаного списка.

![Single linked list](https://upload.wikimedia.org/wikipedia/commons/thumb/9/9c/Single_linked_list.png/600px-Single_linked_list.png)

#### Рис.6. Логическая структура односвязного списка

![Doubly linked list](https://upload.wikimedia.org/wikipedia/commons/thumb/c/ca/Doubly_linked_list.png/600px-Doubly_linked_list.png)

#### Рис.7. Логическая структура двусвязаного списка

![Circular linked list](https://upload.wikimedia.org/wikipedia/commons/thumb/9/98/Circurlar_linked_list.png/600px-Circurlar_linked_list.png)

#### Рис.8. Логическая структура кольцевого связанного списка

**19. Класс Бинарное дерево. Реализовать метод симметричного обхода дерева с выводом списка вершин.**

> *Бинарное дерево* -  иерархическая структура данных, в которой каждый узел имеет не более двух потомков (детей).

Реализация метода симметричного обхода дерева с выводом списка вершин:

```c++
void sym_print(TreeNode *root)
{
    if (root == NULL)           // Базовый случай
    {
       return;
    }
    sym_print(root->left);      //рекурсивный вызов левого поддерева
    cout << root->data << " ";
    sym_print(root->right);     //рекурсивный вызов правого поддерева
}
```

См. так же вопрос №15.

**20. Инфиксная и постфиксная запись выражения. Алгоритм создания постфиксной записи арифметического выражения из инфиксной. Пример создания постфиксной записи арифметического выражения (схема преобразования).**

См. впоросы №6 и №7.
