# Ответы на вопросы по струкутурам и алгоритмам обработки данных

**1. В чем заключаются достоинства и недостатки последовательного и связанного способов реализации динамических структур данных?**

В первом случае базовой структурой, на основе которой строится новая структура данных, является массив. Выделается определенная часть памяти, достаточная для хранения максимального количества элементов. Такой подход является более простым в реализации, но у него есть минусы:

    1. Изменение длины структуры не должно выходить за отведенное ей
       количество памяти;
    2. Неэкономное использование памяти;

Реализация связанным способом более сложна, но она лишена недостатков последовательного способа.

**2. Назовите принципы функционирования стека, очереди и деки?**

Стеком называется упорядоченный набор элементов, в котором включение новых элементов и исключение существующих выполняются только с одного конца, называемого вершиной стека. Каждый элемент стека характеризуется одним и тем же набором полей. Логическая структура стека:

![Stack](https://i.imgur.com/IkwrAig.png)

Очередью называется упорядоченный набор элементов, которые могут исключаться с одного ее конца (называемого началом очереди), а включаться с другого конца (называемого концом очереди). Каждый элемент очереди характеризуется одним и тем же набором полей. Логическая структура очереди:

![Queue](https://i.imgur.com/rTl9Y9v.png)

Декой (DEQ – от английского double ended queue, очередь с двумя концами) называется упорядоченный набор элементов, включение и исключение элементов в котором могут осуществляться с любого из двух его концов. Логическая структура деки:

![Dequeue](https://i.imgur.com/Fi2jwku.png)

**3. Реализуйте класс – стек с базовым набором методов на основе массива нетипированных указателей на размещенные в динамической памяти элементы.**

```c++
template <typename T>
class Stack
{
private:
    T *stackPointer;                // Указатель на стек
    const int size;                 // Максимальное количество
                                    // элементов в стеке
    int top;                        // Номер текущего элемента
public:
    Stack(int = 10);                // Конструктор
    ~Stack();                       // Деструктор

    inline void push(const T & );   // Поместить элемент
                                    // в вершину стека
    inline T pop();                 // Удалить элемент из вершины
                                    // стека и вернуть его
    inline bool empty() const;      // Пуст ли стек
};

// Реализация методов шаблона класса Stack

// Конструктор Стека
template <typename T>
Stack<T>::Stack(int maxSize) :
    size(maxSize) // Инициализация константы
{
    stackPointer = new T[size]; // Выделить память под стек
    top = 0; // Инициализируем текущий элемент нулем;
}

// Функция деструктора Стека
template <typename T>
Stack<T>::~Stack()
{
    delete [] stackPointer; // Удаляем стек
}

// Функция добавления элемента в стек
template <typename T>
inline void Stack<T>::push(const T &value)
{
    // Проверяем размер стека
    assert(top < size);
    stackPointer[top++] = value; // Помещаем элемент в стек
}

// Функция удаления элемента из стека
template <typename T>
inline T Stack<T>::pop()
{
    // Проверяем размер стека
    assert(top > 0);
    return stackPointer[--top]; // Удаляем элемент из стека
}

// Пуст ли стек
template <typename T>
inline bool Stack<T>::empty() const
{
    return (size == 0 ? true : false);
}
```

**4. С использованием основных методов работы со стеком составьте программу копирования элементов стека в новый стек в том же порядке.**

```c++
tempate <typename T>
void copy_stack(Stack<T> &dest, Stack<T> from)
{
    /*
    * Нужна дополнительная временная переменная
    * для копирования в том же порядке,
    * т.к. можно использовать только основные методы стека:
    * push, pop и empty
    */

    Stack<T> tmp;

    while (from.empty() != true) {  // Копирование во временный стек
        tmp.push(from.pop());
    }
    while (tmp.empty() != true) { // Копирование в стек назначения
        dest.push(tmp.pop());
    }
}
```

**5. Реализуйте метод копирования элементов очереди в новую очередь.**

```c++
/*
* Программа написанна с учетом того,
* что можно использовать только основные методы очереди:
* insert, remove и empty
*/

template <typename T>
void copy_queue(Queue<T> &dest, Queue<T> from)
{
    while(from.emty() != true) {
        dest.insert(from.remove());
    }
}
```

**6. Перевод из инфиксной формы записи выражения в префиксную.**

Инфиксное выражение сканируется справа налево, и префиксная строка строится также справа налево. Алгоритм преобразования такой же, как и при преобразовании в постфиксную форму (см. вопрос #7), только открывающие скобки меняются на закрывающие и, наоборот, при определении приоритета операции «<=» изменяется на «<», чтобы равноприоритетные операции выполнялись слева направо.