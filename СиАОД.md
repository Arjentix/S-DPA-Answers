# Ответы на вопросы по струкутурам и алгоритмам обработки данных

**1. В чем заключаются достоинства и недостатки последовательного и связанного способов реализации динамических структур данных?**

В первом случае базовой структурой, на основе которой строится новая структура данных, является массив. Выделается определенная часть памяти, достаточная для хранения максимального количества элементов. Такой подход является более простым в реализации, но у него есть минусы:

    1. Изменение длины структуры не должно выходить за отведенное ей
       количество памяти;
    2. Неэкономное использование памяти;

Реализация связанным способом более сложна, но она лишена недостатков последовательного способа.

**2. Назовите принципы функционирования стека, очереди и деки?**

Стеком называется упорядоченный набор элементов, в котором включение новых элементов и исключение существующих выполняются только с одного конца, называемого вершиной стека. Каждый элемент стека характеризуется одним и тем же набором полей. Логическая структура стека:

![Stack](https://i.imgur.com/IkwrAig.png)

Очередью называется упорядоченный набор элементов, которые могут исключаться с одного ее конца (называемого началом очереди), а включаться с другого конца (называемого концом очереди). Каждый элемент очереди характеризуется одним и тем же набором полей. Логическая структура очереди:

![Queue](https://i.imgur.com/rTl9Y9v.png)

Декой (DEQ – от английского double ended queue, очередь с двумя концами) называется упорядоченный набор элементов, включение и исключение элементов в котором могут осуществляться с любого из двух его концов. Логическая структура деки:

![Dequeue](https://i.imgur.com/Fi2jwku.png)

**3. Реализуйте класс – стек с базовым набором методов на основе массива нетипированных указателей на размещенные в динамической памяти элементы.**

```c++
template <typename T>
class Stack
{
private:
    T *stackPointer;                // Указатель на стек
    const int size;                 // Максимальное количество
                                    // элементов в стеке
    int top;                        // Номер текущего элемента
public:
    Stack(int = 10);                // Конструктор
    ~Stack();                       // Деструктор

    inline void push(const T & );   // Поместить элемент
                                    // в вершину стека
    inline T pop();                 // Удалить элемент из вершины
                                    // стека и вернуть его
    inline bool empty() const;      // Пуст ли стек
};

// Реализация методов шаблона класса Stack

// Конструктор Стека
template <typename T>
Stack<T>::Stack(int maxSize) :
    size(maxSize) // Инициализация константы
{
    stackPointer = new T[size]; // Выделить память под стек
    top = 0; // Инициализируем текущий элемент нулем;
}

// Функция деструктора Стека
template <typename T>
Stack<T>::~Stack()
{
    delete [] stackPointer; // Удаляем стек
}

// Функция добавления элемента в стек
template <typename T>
inline void Stack<T>::push(const T &value)
{
    // Проверяем размер стека
    assert(top < size);
    stackPointer[top++] = value; // Помещаем элемент в стек
}

// Функция удаления элемента из стека
template <typename T>
inline T Stack<T>::pop()
{
    // Проверяем размер стека
    assert(top > 0);
    return stackPointer[--top]; // Удаляем элемент из стека
}

// Пуст ли стек
template <typename T>
inline bool Stack<T>::empty() const
{
    return (size == 0 ? true : false);
}
```

**4. С использованием основных методов работы со стеком составьте программу копирования элементов стека в новый стек в том же порядке.**

```c++
tempate <typename T>
Stack<T> copy_stack(Stack<T> from)
{
    /*
    * Нужна дополнительная временная переменная
    * для копирования в том же порядке,
    * т.к. можно использовать только основные методы стека:
    * push, pop и empty
    */

    Stack<T> dest;
    Stack<T> tmp;

    while (from.empty() != true) {  // Копирование во временный стек
        tmp.push(from.pop());
    }
    while (tmp.empty() != true) { // Копирование в стек назначения
        dest.push(tmp.pop());
    }

    return dest;
}
```

**5. Реализуйте метод копирования элементов очереди в новую очередь.**

```c++
/*
* Программа написанна с учетом того,
* что можно использовать только основные методы очереди:
* insert, remove и empty
*/

template <typename T>
Queue<T> copy_queue(Queue<T> from)
{
    Queue<T> dest;

    while(from.emty() != true) {
        dest.insert(from.remove());
    }

    return dest;
}
```

**6. Перевод из инфиксной формы записи выражения в префиксную.**

Инфиксное выражение сканируется справа налево, и префиксная строка строится также справа налево. Алгоритм преобразования такой же, как и при преобразовании в постфиксную форму (см. вопрос №7), только открывающие скобки меняются на закрывающие и, наоборот, при определении приоритета операции «<=» изменяется на «<», чтобы равноприоритетные операции выполнялись слева направо.

**7. Перевод инфиксной формы записи выражения в постфиксную.**

Инфиксное выражение сканируется слева направо, и в зависимости от вида очередного элемента выражения выполняется одно из следующих действий:

|  Элемент выражения  |  Действие  |
| :--- | :--- |
|  Открывающая скобка  |  Вталкивание элемента в стек.  |
|  Операнд  |  Запись элемента в постфиксную строку.  |
|  Закрывающая скобка  |  Выталкивание элементов из стека до первой открывающей скобки и запись их в постфиксную строку, затем выталкивание самой открывающей скобки без записи ее в постфиксную строку. Если перед выполнением этой операции стек оказался пустым, значит, для дан-ной закрывающей скобки не было парной открываю-щей, т.е. возникла исключительная ситуация.  |
|  Операция  |  Если стек не пуст, и приоритет операции ниже (<=), чем у верхней операции в стеке, то выталкивание элемен-тов из стека до операции с меньшим приоритетом или до опустошения стека и запись их в постфиксную строку; в противном случае стек не изменяется. Затем вталкивание операции в стек.  |

После просмотра выражения выталкиваются из стека и записываются в постфиксную строку все оставшиеся в стеке операции.

**8. С использованием стандартного набора методов составьте программу переноса из очереди строк в новую очередь элементов начинающихся на буквы «F» или «f».**

```c++
Queue<string> transfer_fbegins_lines(Queue<string> from)
{
    Queue<string> dest;
    string tmp;

    while (from.empty() != true) {
        tmp = from.remove();
        if (tmp[0].tolower() == 'f') {
            dest.push(tmp);
        }
    }
}
```

**9. С использованием стандартного набора методов составьте программу записи элементов очереди в новую очередь в обратном порядке.**

```c++
// Рекурсивная функция
template <typename T>
void copy_reverse_queue(Queue<T> &dest, Queue<T> from)
{
    T tmp;

    // Условие выхода из рекурсии
    if (from.empty() == true) {
        return;
    }

    tmp = from.remove();
    copy_reverse_queue(dest, from);
    dest.insert(tmp);
}
```

**10. АТД – очередь. Ее свойства. Способы реализации.**
См. вопрос №2.
Очередь может быть реализована с помощью массива; односвязанного списка; с помощью двусвязанного списка; на двух стеках.
Реализация на двух стеках:

```c++
template <typename T>
class Queue {
private:
    Stack<T> st1;
    Stack<T> st2;
public:
    Queue();                        // Конструктор
    ~Queue();                       // Деструктор
    inline void insert(T value);    // Вставить элемент в очередь
    inline void remove();           // Удалить первый элемент очереди
    inline bool empty() const;      // Пуста ли очередь
}

template <typename T>
Queue<T>::Queue()
{
}

template <typename T>
Queue<T>::~Queue()
{
}

template <typename T>
void Queue<T>::insert(T value)
{
    st1.push(value);
}

template <typename T>
void Queue<T>::remove()
{
    if (st2.empty() == true) {
        if (st1.empty() == true) {
            exit(-1);
        }

        while(st1.empty != true) {
            st2.insert(st1.remove());
        }
    }

    return st2.remove();
}
```
